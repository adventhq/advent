<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Black Hole Landing Page Animation</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- GSAP CDN for advanced animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: black;
      }
      canvas {
        display: block;
      }
      .overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 10;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div class="overlay text-white">
      <h1 class="text-5xl font-bold mb-4">Enter the Void</h1>
      <p class="text-xl mb-6">Witness the power of gravitational innovation.</p>
      <button
        class="px-6 py-3 bg-blue-600 rounded-lg hover:bg-blue-700 transition"
      >
        Explore Now
      </button>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let width, height;

      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
      }
      resize();
      window.addEventListener("resize", resize);

      // Black hole center
      const centerX = width / 2;
      const centerY = height / 2;
      const blackHoleRadius = 50;

      // Particle class
      class Particle {
        constructor() {
          this.reset();
        }

        reset() {
          this.x = Math.random() * width;
          this.y = Math.random() * height;
          this.size = Math.random() * 5 + 2;
          this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
          this.angle = Math.random() * Math.PI * 2;
          this.distance = Math.sqrt(
            (this.x - centerX) ** 2 + (this.y - centerY) ** 2
          );
          this.speed = Math.random() * 0.005 + 0.01; // Slower base speed
          this.angularSpeed = Math.random() * 0.02 + 0.01; // Spiral speed
          this.trail = []; // For trail effect
          this.trailLength = 20;
        }

        update() {
          // Gravitational pull: reduce distance over time
          this.distance *= 1 - this.speed * (blackHoleRadius / this.distance);

          // Spiral motion
          this.angle += this.angularSpeed * (blackHoleRadius / this.distance);

          // Update position based on polar coordinates
          this.x = centerX + Math.cos(this.angle) * this.distance;
          this.y = centerY + Math.sin(this.angle) * this.distance;

          // Add to trail
          this.trail.push({ x: this.x, y: this.y });
          if (this.trail.length > this.trailLength) {
            this.trail.shift();
          }

          // Distortion near black hole: scale down and fade
          if (this.distance < blackHoleRadius * 2) {
            this.size *= 0.98;
            this.alpha = this.distance / (blackHoleRadius * 2);
          } else {
            this.alpha = 1;
          }

          // Reset if swallowed
          if (this.distance < blackHoleRadius || this.size < 0.1) {
            this.reset();
          }
        }

        draw() {
          ctx.save();
          ctx.globalAlpha = this.alpha || 1;

          // Draw trail
          ctx.beginPath();
          this.trail.forEach((point, i) => {
            ctx.lineTo(point.x, point.y);
            ctx.strokeStyle = `hsla(${parseInt(
              this.color.split(",")[0].slice(4)
            )}, 100%, 70%, ${i / this.trailLength})`;
            ctx.lineWidth = this.size * (i / this.trailLength);
          });
          ctx.stroke();

          // Draw particle
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.restore();
        }
      }

      const particles = [];
      for (let i = 0; i < 100; i++) {
        // More particles for better effect
        particles.push(new Particle());
      }

      // Accretion disk simulation
      function drawBlackHole() {
        // Event horizon
        const gradient = ctx.createRadialGradient(
          centerX,
          centerY,
          0,
          centerX,
          centerY,
          blackHoleRadius * 2
        );
        gradient.addColorStop(0, "black");
        gradient.addColorStop(0.5, "rgba(0,0,0,0.8)");
        gradient.addColorStop(1, "rgba(255,165,0,0.2)"); // Orange glow for accretion

        ctx.beginPath();
        ctx.arc(centerX, centerY, blackHoleRadius * 2, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Pulsing glow with GSAP
        gsap.to(
          { radius: blackHoleRadius },
          {
            radius: blackHoleRadius * 1.1,
            duration: 2,
            repeat: -1,
            yoyo: true,
            onUpdate: function () {
              const glowGradient = ctx.createRadialGradient(
                centerX,
                centerY,
                blackHoleRadius,
                centerX,
                centerY,
                this.targets()[0].radius
              );
              glowGradient.addColorStop(0, "rgba(255,165,0,0.3)");
              glowGradient.addColorStop(1, "rgba(255,165,0,0)");
              ctx.beginPath();
              ctx.arc(
                centerX,
                centerY,
                this.targets()[0].radius,
                0,
                Math.PI * 2
              );
              ctx.fillStyle = glowGradient;
              ctx.fill();
            },
          }
        );
      }

      function animate() {
        ctx.clearRect(0, 0, width, height);

        // Draw starry background
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        for (let i = 0; i < 200; i++) {
          ctx.beginPath();
          ctx.arc(
            Math.random() * width,
            Math.random() * height,
            Math.random() * 1,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }

        drawBlackHole();

        particles.forEach((p) => {
          p.update();
          p.draw();
        });

        requestAnimationFrame(animate);
      }

      animate();

      // Use GSAP for overlay animation
      gsap.from(".overlay", { opacity: 0, y: 50, duration: 2, delay: 1 });
    </script>
  </body>
</html>
